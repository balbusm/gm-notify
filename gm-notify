#!/usr/bin/python3
# -*- coding: utf-8 -*-

# gm-notify v1.0
# a simple and lightweight GMail-Notifier for ubuntu and notify-osd
#
# Copyright (c) 2009-2010, Alexander Hungenberg <alexander.hungenberg@gmail.com>
# Copyright (c) 2015, Mateusz Balbus <balbusm@gmail.com>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import sys
import subprocess
import gettext
import webbrowser
import re
import signal
from typing import List, Dict

from bs4 import BeautifulSoup
from rx import Observable
from rx.concurrency import GtkScheduler

from atom_checker import AtomChecker

import gi
gi.require_version('Gst', '1.0')
gi.require_version('MessagingMenu', '1.0')
gi.require_version('Notify', '0.7')
from gi.repository import Gio, GLib, Gst, MessagingMenu, Notify

import account_settings_provider
import gm_log

_ = gettext.translation('gm-notify', fallback=True).gettext

MAILBOXES_NAMES = { "inbox": _("Inbox") }

MAILBOXES_URLS = {  "inbox": "" }

GMAIL_DOMAINS = ['gmail.com','googlemail.com']

EMAIL_RETRIEVAL_ERROR = "--retrieval-error"


class PathNotFound(Exception): pass


def get_executable_path(name):
    path = "%s/%s" % (os.getcwd(), name)
    if os.path.exists(path) and os.access(path, os.X_OK): return path
    path = "/usr/local/bin/" + name
    if os.path.exists(path) and os.access(path, os.X_OK): return path
    path = "/usr/bin/" + name
    if os.path.exists(path) and os.access(path, os.X_OK): return path
    raise PathNotFound("%s not found" % name)


class Account:
    def __init__(self, username: str):
        self.username = username
        # check if we use Google Apps to start the correct webinterface
        self.domain = self._retrieve_domain(username)
        self.client = None
        self.soundfile = None
        self.ignore_inbox = None
        self.labels = None
        self.use_mail_client = None
        self.disposable = None

    def _retrieve_domain(self, username):
        domain_regex = re.search("@([\w.]+)", username)
        domain = domain_regex.group(1)
        if domain in GMAIL_DOMAINS:
            return None
        return domain


class CheckMail(Gio.Application):
    def __init__(self):
        '''initiates DBUS-Messaging interface, creates the MailChecker and registers with indicator-applet.
        In the end it starts the periodic check timer and a gtk main-loop'''
        super(CheckMail, self).__init__(application_id="net.launchpad.gm-notify",
            flags=Gio.ApplicationFlags.FLAGS_NONE)

        self.player = None
        self._has_activated = False
        self._counts = {}
        self.accounts = None
        self.notification = list()
        self.connect("activate", self.on_activate)
        self.logger = gm_log.get_logger("gm-notify")

    def play_sound(self, name):
        '''Uses GSound to play the music'''
        if name is None:
            return
        
        if not self.player: 
            Gst.init()
            self.player = Gst.ElementFactory.make("playbin", "player")

        self.player.set_property("uri", "file://" + name)
        result = self.player.set_state(Gst.State.PLAYING)
        if result == Gst.StateChangeReturn.FAILURE:
            self.logger.warning("Unable to play %s", name)

    def on_remote_quit(self, action, args):
        '''Stops the application when the "remote-quit" action is activated'''
        self.quit()

    def on_activate(self, app):
        '''When first receiving the activate signal, initialize the primary
        instance. On subsequent activate signals, we are being activated from a
        secondary instance, so treat it as if our name was clicked in the
        messaging menu.'''
        if self._has_activated:
            self.indicator_clicked()
            return

        self._has_activated = True

        # Add an action to quit
        quit_action = Gio.SimpleAction.new("remote-quit", None)
        quit_action.connect("activate", self.on_remote_quit)
        self.add_action(quit_action)

        # Initialize the desktop notifications
        if not Notify.init(_("GMail Notifier")):
            sys.exit(-1)

        available_accounts = account_settings_provider.list_accounts()
        if not available_accounts:
            self.logger.info("Failed to get credentials")
            self.run_config_app()
            sys.exit(-1)

        # Messaging Menu integration
        self._m_menu = MessagingMenu.App.new("gm-notify.desktop")
        self._m_menu.register()
        self._m_menu.connect("activate-source", self.source_clicked)

        self.accounts = self.init_accounts(available_accounts)

    def run_config_app(self) -> None:
        # Start gm-notify-config if no credentials are found
        try:
            subprocess.call(get_executable_path("gm-notify-config"))
        except PathNotFound:
            self.logger.warning(_("gm-notify-config utility was not found"))

    def init_accounts(self, available_accounts_names: List[str]) -> Dict[str, Account]:
        accounts = {}
        for account_name in available_accounts_names:
            account = Account(account_name)
            accounts[account_name] = account
            
            client = account_settings_provider.create_settings_provider(account_name)
            account.client = client 
            
            account.use_mail_client = client.retrieve_use_mail_client()
            
            # Set up the sound file
            if client.retrieve_sound_enabled():
                account.soundfile = client.retrieve_sound_file("message-new-instant")
            # Read ignore-inbox value. If true you will only receive notifications
            # about configured labels
            account.ignore_inbox = client.retrieve_ignore_inbox()
            
            # Retrieve the mailbox we're gonna check
            account.labels = client.retrieve_labels()
            account.labels.insert(0, "inbox")

            account.checker = AtomChecker(account_name, account.labels)

            observable = Observable.create(account.checker.connect, ) \
                .subscribe_on(GtkScheduler()) \
                .observe_on(GtkScheduler()) \
                .do_action(on_next=lambda atom_message: self.logger.info("> %s: %s",
                                                                atom_message.account_name,
                                                                atom_message.response.text),
                           on_error=self.checker_connection_error) \
                .on_error_resume_next(Observable.empty()) \
                .publish()

            # successful login flow
            observable.filter(lambda atom_message: atom_message.response.status_code == 200) \
                .map(lambda atom_message:
                                 (atom_message.account_name, atom_message.label, BeautifulSoup(atom_message.response.text, "xml"))) \
                .do_action(on_next=lambda soup_message: self.update_count(*soup_message)) \
                .subscribe(on_next=lambda soup_message: self.new_mail(*soup_message),
                           on_error=self.handle_exception)
            # failed login flow
            observable.filter(lambda atom_message: atom_message.response.status_code != 200) \
                .map(lambda atom_message: (atom_message.account_name, str(atom_message.response.status_code) + " " + atom_message.response.reason)) \
                .subscribe(on_next=lambda error_message: self.checker_auth_failed(*error_message),
                           on_error=self.handle_exception)

            account.disposable = observable.connect()

        return accounts

    def handle_exception(self, ex: Exception) -> None:
        self.logger.exception("Exception during processing atom message", exc_info=ex)

    def indicator_clicked(self):
        '''called when "Google Mail" is clicked in indicator-messages and
        performs a Mail Check'''
        for username, account in self.accounts.items():
            for label in account.labels:
                self.remove_attention(self.compose_id(username, label))
            
        for username, account in self.accounts.items():
            account.checker.fetch_inbox()

    def compose_label(self, username, label):
        return "%s (%s)" % (username, label)

    def compose_id(self, username, label):
        return "%s&%s" % (username, label)
    
    def decompose_id(self, id):
        decomposed = id.split("&")
        return (decomposed[0], decomposed[1])

    def remove_attention(self, label):
        '''Removes attention from the label source if it exists'''
        if self._m_menu.has_source(label):
            self._m_menu.remove_attention(label)

    def has_source(self, account_name: str, label: str) -> bool:
        '''Returns true if we have this label, or if we don't and it is in our
        mailboxes list, create it'''
        account = self.accounts[account_name]
        if label == "inbox" and account.ignore_inbox:
            return False
        elif label in account.labels:
            mail_label = self.compose_id(account_name, label)
            if not self._m_menu.has_source(mail_label):
                if label in MAILBOXES_NAMES:
                    name = MAILBOXES_NAMES[label]
                else:
                    name = label
                name_label = self.compose_label(account_name, name)
                if label == "inbox":
                    self._m_menu.insert_source_with_string(0, mail_label, None, name_label, _("empty"))
                else:
                    self._m_menu.append_source_with_string(mail_label, None, name_label, _("empty"))
                if mail_label in self._counts:
                    self._m_menu.set_source_count(mail_label, self._counts[mail_label])
            return True
        else:
            return False

    def update_count(self, account_name: str, label: str, soup: BeautifulSoup) -> None:
        '''Updates the count for all the mailboxes'''
        account = self.accounts[account_name]
        if label == "inbox" and account.ignore_inbox:
            return

        if self.has_source(account_name, label):
            # Get the last count
            last_count = 0
            mail_label = self.compose_id(account_name, label)
            if mail_label in self._counts:
                last_count = self._counts[mail_label]
            current_count = len(soup.find_all("entry"))

            # Remove attention if the count has decreased
            if last_count > current_count:
                self._m_menu.remove_attention(mail_label)
            if current_count > 0:
                self._m_menu.set_source_count(mail_label, current_count)
            # Remove the source if 0 messages, to save space
            else:
                self._m_menu.remove_source(mail_label)
            self._counts[mail_label] = current_count
    
    def new_mail(self, account_name: str, label: str, soup: BeautifulSoup) -> None:
        '''Takes mailbox name and titles of mails, to display notification and add indicators'''
        account = self.accounts[account_name]
        # aggregate the titles of the messages... cut the string if longer than 30 chars
        got_label = False
        if label == "inbox" and account.ignore_inbox:
            return
        if self.has_source(account_name, label):
            got_label = True
            mail_label = self.compose_id(account_name, label)
            self._m_menu.draw_attention(mail_label)
        if not got_label:
            return

        for entry in soup.find_all("entry"):
            text = ""

            author_name = entry.author.find("name")
            if author_name:
                text += author_name.text + ":\n"
            elif entry.author.email:
                text += entry.author.email.text + ":\n"

            if entry.title:
                title = entry.title.text
                if len(title) > 30:
                    title = title[:30] + "..."
            elif entry.summary:
                title = entry.summary.text[:30] + "..."
            else:
                title = _("(no content)")
            text += "- " + title + "\n"

            if text:
                self.show_notification("{0}".format(account_name), text.strip("\n"))
                self.play_sound(self.accounts[account_name].soundfile)
    

    def source_clicked(self, app, source_id):
        '''called when a label is clicked in the indicator-applet and opens the corresponding gmail page'''
        # TODO: missing username
        username, label = self.decompose_id(source_id)
        if label == EMAIL_RETRIEVAL_ERROR:
            return
        account = self.accounts[username]
        
        # Open mail client
        if account.use_mail_client:
            try:
                info = Gio.AppInfo.get_default_for_type("x-scheme-handler/mailto", False)
                info.launch(None, None)
            except:
                pass
        else:
            url = self.prep_url(account, label)
            webbrowser.open(url)

    def prep_url(self, account, label):
        url_domain = self.prep_url_domain(account.domain)
        url_label = self.prep_url_label(label)

        return ("https://accounts.google.com/AccountChooser?"
                "Email={0}"
                "&continue=https%3A%2F%2Fmail.google.com%2Fmail%2F{1}"
                "&service=mail"
                "&hd={2}").format(account.username, url_label, url_domain)

    def prep_url_label(self, label):
        if label in MAILBOXES_URLS:
            return "%23{0}".format(MAILBOXES_URLS[label])
        else:
            return "%23label%2F{0}".format(label)

    def prep_url_domain(self, domain):
        if domain:
            return domain
        else:
            return "default"
    
    def checker_auth_succeeded(self, username):
        error_label = self.compose_id(username, EMAIL_RETRIEVAL_ERROR)
        self._m_menu.remove_source(error_label)
    
    def checker_connection_error(self, account_name, ex: Exception) -> None:
        self.logger.warning("Cannot retrieve emails", exc_info=ex)
        self.check_failed(account_name, _("Cannot retrieve emails"))
    
    def checker_auth_failed(self, account_name, ex: Exception) -> None:
        self.logger.warning("Authentication failed", exc_info=ex)
        self.check_failed(account_name, _("Authentication failed"))
    
    def check_failed(self, username, feed):
        
        for id in self._counts:
            local_username, local_label = self.decompose_id(id)
            if local_username == username:
                self._m_menu.remove_source(id)
            
        error_id = self.compose_id(username, EMAIL_RETRIEVAL_ERROR)
        if self._m_menu.has_source(error_id):
            return
        self._m_menu.append_source(error_id, None, username + _(" - Cannot retrieve emails"))
        n = Notify.Notification.new(_("Error for ") + username, feed, "messagebox_critical")
        n.show()
    
    def show_notification(self, title, message):
        '''takes a title and a message to display the email notification. Returns the
        created notification object'''
        
        n = Notify.Notification.new(title, message, "/home/mati/Develop/gm-notify/gm-notify/data/notification-message-email")
        n.show()

        self.notification.append(n)
        if self.notification[0]:
            self.notification[0].update("text " + str(len(self.notification)))
            self.notification[0].show()
        
        return n
    
    def shutdown(self):
        if self.accounts: 
            for username, account in self.accounts.items():
                if account.checker : account.checker.stop()
    
cm = CheckMail()
cm.register()
if not cm.get_is_remote():
    # enables Ctr + C termination
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    cm.hold()

cm.run()
cm.shutdown()

